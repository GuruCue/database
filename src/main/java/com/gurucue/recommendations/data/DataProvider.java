/*
 * This file is part of Guru Cue Search & Recommendation Engine.
 * Copyright (C) 2017 Guru Cue Ltd.
 *
 * Guru Cue Search & Recommendation Engine is free software: you can
 * redistribute it and/or modify it under the terms of the GNU General
 * Public License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * Guru Cue Search & Recommendation Engine is distributed in the hope
 * that it will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Guru Cue Search & Recommendation Engine. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package com.gurucue.recommendations.data;

import com.gurucue.recommendations.entity.ConsumerEvent;

/**
 * The data provider interface implemented by storage back-ends.
 */
public interface DataProvider extends AutoCloseable {
    /**
     * Returns a thread-safe concurrent <code>DataLink</code> instance. This
     * usually means each thread gets its own <code>DataLink</code> instance,
     * which stays the same across calls inside the same thread, until the
     * <code>close()</code> is invoked.
     *
     * @return a <code>DataLink</code> instance
     */
    DataLink newDataLink();

    /**
     * Clears any cached entities, if provider implements internal caching.
     */
    void clearCaches();

    /**
     * Closes any outstanding links and frees all resources occupied by the
     * provider. After this the provider must not be used anymore.
     */
    @Override
    void close();

    /**
     * Register a CloseListener for when this provider will be closed.
     * @param closeListener the listener instance
     */
    void registerOnClose(CloseListener closeListener);

    /**
     * Execute the given job asynchronously in another thread, returning immediately.
     * @param job the job to execute asynchronously
     */
    void runAsync(Runnable job);

    /**
     * Returns an instance with all the attribute codes.
     * @return the container with attribute codes
     */
    AttributeCodes getAttributeCodes();

    /**
     * Returns an instance with all the product type codes.
     * @return the container with product type codes
     */
    ProductTypeCodes getProductTypeCodes();

    /**
     * Returns an instance with all the consumer event type codes.
     * @return the container with consumer event type codes
     */
    ConsumerEventTypeCodes getConsumerEventTypeCodes();

    /**
     * Returns and instance with all the data type codes.
     * @return the container with data type codes
     */
    DataTypeCodes getDataTypeCodes();

    /**
     * Returns an instance with all the language codes.
     * @return the container with language codes
     */
    LanguageCodes getLanguageCodes();

    /**
     * Queues results of the consumer event service for later (asynchronous)
     * storage. Therefore the data storage is done in a separate transaction,
     * in a separate thread.
     * Generated consumer events should supply a null log entry.
     * When a log entry is missing, then the request timestamp will be the
     * event timestamp.
     *
     * @param consumerEventLog the consumer event log instance generated by the consumer event service
     * @param consumerEvent the consumer event instance generated by the consumer event service
     * @throws InterruptedException if interrupted during the queueing procedure
     */
    //void queueConsumerEvent(LogSvcConsumerEvent consumerEventLog, ConsumerEvent consumerEvent) throws InterruptedException;

    /**
     * Queues results of the consumer event service for later (asynchronous)
     * storage. Therefore the data storage is done in a separate transaction,
     * in a separate thread.
     *
     * @param consumerEvent the consumer event instance generated by the consumer event service
     * @throws InterruptedException if interrupted during the queueing procedure
     */
    void queueConsumerEvent(ConsumerEvent consumerEvent) throws InterruptedException;

    /**
     * Resizes the buffer for consumer event queueing.
     *
     * @param newSize the new size of the consumer event queue
     */
    void resizeConsumerEventQueueSize(int newSize);

    /**
     * Resizes the thread pool for processing the consumer event queue.
     *
     * @param newSize the new number of threads for processing the consumer event queue
     */
    void resizeConsumerEventQueueThreadPool(int newSize);

    /**
     * Register interest about consumers' life-cycle.
     * @param listener the listener instance
     */
    void registerConsumerListener(ConsumerListener listener);

    /**
     * Unregister interest about consumers' life-cycle.
     * @param listener the listener instance
     */
    void unregisterConsumerListener(ConsumerListener listener);
}
